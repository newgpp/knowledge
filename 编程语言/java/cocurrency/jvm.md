# jvm

## 一、jvm内存结构

### 1. 方法区、虚拟机栈、本地方法栈、堆内存、程序计数器

1. 程序计数器: 程序计数器在JVM中所起的作用就是用于存放当前线程接下来要执行的字节码指令、分支、循环、跳转、异常处理等信息。在任何时候，一个处理器只执行其中一个线程中的指令，为了能够在CPU时间片轮转切换上下文之后顺利回到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间相互不影响，因此JVM将此块内存区域设计成了线程私有的。

2. Java虚拟机栈: Java虚拟机栈也是线程私有的，它的声明周期与线程相同，是在JVM运行时创建的，在线程中，方法在执行的时候都会创建一个名为栈帧（stack frame）的数据结构，主要用于存放局部变量表、操作栈、动态链接、方法出口等信息，方法的调用对应着栈帧在虚拟机栈中的压栈和弹栈过程。虚拟机栈的大小可以通过-xss来配置，方法的调用是栈帧被压入和弹出的过程，一般将栈帧内存的大小称为宽度，而栈帧的数量则称为虚拟机栈的深度。

3. 本地方法栈: Java中提供了调用本地方法的接口（Java Native Interface），也就是C/C++程序，在线程执行的过程中，经常会碰到调用JNI方法的情况，比如网络通信、文件操作的底层，JVM为本地方法划分的内存区域便是本地方法栈，同样也是线程私有的内存区域。

4. 堆内存:堆内存是JVM中最大的一块内存区域，被所有的线程共享Java在运行期间创建的所有对象几乎都存放在该内存区域，该内存区域也是垃圾回收器重点照顾的区域。堆内存一般会被分为新生代和老年代，更细致的划分为Eden区，From Survivor区和To Survivor区。

5. 方法区: 方法区也是被多个线程所共享的内存区域，它主要用于存储已经被虚拟机加载的类信息、常量、静态常量、即时编译器（JIT）编译后的代码等数据。

6. Java8元空间: JDK1.8版本起，持久代（PermGen）内存被彻底删除，取而代之的是元空间（Meta Space），元空间同样是堆内存的一部分。

### 2. 对象的内存分布

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域:

- 对象头(Header)
- 实例数据(Instance Data)
- 对齐填充(Padding)

#### 2.1 HotSpot虚拟机的对象头包括两部分信息

分类|说明
---|---
对象自身的运行时数据|HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。官方称之为Mark Word
类型指针|指向它的类元数据的指针，如果对象是java数组，那在对象头中还必须有一块用于记录数组长度的数据

#### 2.2 实例数据部分是对象真正存储的有效信息，无论是父类继承下来的还是子类中定义的

#### 2.3 对齐填充并不是必然存在的，仅仅是起到占位符的作用

### 3. OutOfMemoryError异常

在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM的可能。

#### 3.1 Java堆溢出

Java堆用于存储对象实例，只要不断的创建对象，并且保证GC Roots到对象之间有可达领来避免垃圾回收机制清除这些对象，那么当对象数量达到最大堆的容量限制之后就会产生内存溢出异常。

1. 启动参数 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${dir}
2. 异常 java.lang.OutOfMemoryError: Java heap space
3. dump文件名称 java_pid4344.hprof

解决方案:

1. 一般手段是先通过内存映像分析工具(jhat ${dir})对dump出来的堆转储快照进行分析，重点是确认内存中对象是否是必要的，要区分内存泄漏和内存溢出。
2. 内存泄露可以通过工具查看泄露对象到GC Roots的引用链，于是就能找到泄露对象是通过怎样的路径与GC Roots相关联倒找垃圾收集器无法自动回收他们。
3. 如果不存在泄露，就是内存中的对象确实都还必须活着，那就应当检查虚拟机的堆参数(-Xmx)，从代码上检查是否存在某些对象生命周期过长。

#### 3.2 虚拟机栈和本地方法栈溢出

查看默认的虚拟机栈空间的内存大小 java -XX:+PrintFlagsFinal -version | grep ThreadStackSize

在Java虚拟机规范中描述了两种异常:

1. 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
2. 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError

实验

1. 启动参数 -Xss128k
2. 异常 java.lang.StackOverflowError
3. 分析在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。

#### 3.3 方法区和运行时常量池溢出

-XX:PermSize=10M -XX:MaxPermSize=10M